# MDCRenderer Component

The `MDCRenderer` is a Vue 3 component that renders parsed MDC AST (Abstract Syntax Tree) into Vue components and HTML elements.

## Overview

`MDCRenderer` takes an MDC AST (from `parse()` or `parseStream()`) and renders it as Vue components, with support for:
- Custom component mapping
- Slot support for MDC components
- Dynamic component resolution
- Error boundary handling
- Streaming-friendly rendering

## Installation

```typescript
import { MDCRenderer } from 'mdc-syntax/vue'
```

## Basic Usage

```vue
<script setup lang="ts">
import { parse } from 'mdc-syntax'
import { MDCRenderer } from 'mdc-syntax/vue'

const content = `# Hello World

This is **markdown** with MDC components.

::alert{type="info"}
This is an alert!
::`

const result = parse(content)
const mdcAst = result.body
</script>

<template>
  <MDCRenderer :body="mdcAst" />
</template>
```

## Props

### `body` (required)

The MDC AST root node to render.

**Type:** `MinimarkTree`

```typescript
interface MinimarkTree {
  type: 'minimark'
  value: MinimarkNode[]
}
```

**Example:**

```vue
<script setup>
import { parse } from 'mdc-syntax'
import { MDCRenderer } from 'mdc-syntax/vue'

const result = parse('# Hello\n\nContent here')
</script>

<template>
  <MDCRenderer :body="result.body" />
</template>
```

### `components` (optional)

Custom Vue component mappings for specific tags.

**Type:** `Record<string, Component>`
**Default:** `{}`

**Example:**

```vue
<script setup lang="ts">
import { MDCRenderer } from 'mdc-syntax/vue'
import CustomAlert from './components/CustomAlert.vue'
import CustomHeading from './components/CustomHeading.vue'

const customComponents = {
  // Map MDC components
  alert: CustomAlert,

  // Override HTML elements
  h1: CustomHeading,
  h2: CustomHeading,
}
</script>

<template>
  <MDCRenderer :body="mdcAst" :components="customComponents" />
</template>
```

### `componentsManifest` (optional)

Dynamic component resolver function for lazy-loading components.

**Type:** `(name: string) => Promise<Component>`
**Default:** `undefined`

**Example:**

```vue
<script setup lang="ts">
import { MDCRenderer } from 'mdc-syntax/vue'

// Dynamic component resolution
function resolveComponent(name: string) {
  return import(`./components/${name}.vue`)
}
</script>

<template>
  <MDCRenderer
    :body="mdcAst"
    :components-manifest="resolveComponent"
  />
</template>
```

## Custom Components

### Creating a Custom Component

Custom components receive the MDC node as a prop and can access all props defined in the markdown:

```vue
<!-- components/CustomAlert.vue -->
<script setup lang="ts">
import { computed } from 'vue'

const props = defineProps<{
  type?: 'info' | 'warning' | 'error' | 'success'
  __node?: any
}>()

const icon = computed(() => {
  switch (props.type) {
    case 'info': return 'ℹ️'
    case 'warning': return '⚠️'
    case 'error': return '❌'
    case 'success': return '✅'
    default: return 'ℹ️'
  }
})
</script>

<template>
  <div class="alert" :class="`alert-${type}`">
    <div class="alert-icon">
      {{ icon }}
    </div>
    <div class="alert-content">
      <slot />
    </div>
  </div>
</template>

<style scoped>
.alert {
  padding: 1rem;
  border-radius: 0.5rem;
  display: flex;
  gap: 0.75rem;
}

.alert-info { background: #e3f2fd; }
.alert-warning { background: #fff3e0; }
.alert-error { background: #ffebee; }
.alert-success { background: #e8f5e9; }
</style>
```

**Usage in markdown:**

```markdown
::alert{type="info"}
This is an informational alert!
::

::alert{type="warning"}
This is a warning!
::
```

### Component with Multiple Slots

```vue
<!-- components/CustomCard.vue -->
<template>
  <div class="card">
    <div v-if="$slots.header" class="card-header">
      <slot name="header" />
    </div>
    <div class="card-body">
      <slot />
    </div>
    <div v-if="$slots.footer" class="card-footer">
      <slot name="footer" />
    </div>
  </div>
</template>

<style scoped>
.card {
  border: 1px solid #ddd;
  border-radius: 0.5rem;
  overflow: hidden;
}

.card-header {
  background: #f5f5f5;
  padding: 1rem;
  font-weight: 600;
}

.card-body {
  padding: 1rem;
}

.card-footer {
  background: #f5f5f5;
  padding: 1rem;
  border-top: 1px solid #ddd;
}
</style>
```

**Usage in markdown:**

```markdown
::card
#header
Card Title
#footer
Card footer content

This is the card body content.
::
```

### Overriding HTML Elements

You can override default HTML rendering:

```vue
<!-- components/CustomHeading.vue -->
<script setup lang="ts">
import { computed } from 'vue'

const props = defineProps<{
  __node?: any
  id?: string
}>()

const tag = computed(() => props.__node?.tag || 'h2')
</script>

<template>
  <component
    :is="tag"
    :id="id"
    class="custom-heading"
  >
    <a :href="`#${id}`" class="heading-anchor">#</a>
    <slot />
  </component>
</template>

<style scoped>
.custom-heading {
  position: relative;
}

.heading-anchor {
  position: absolute;
  left: -1.5rem;
  opacity: 0;
  text-decoration: none;
  color: #999;
}

.custom-heading:hover .heading-anchor {
  opacity: 1;
}
</style>
```

**Usage:**

```vue
<script setup>
const customComponents = {
  h1: CustomHeading,
  h2: CustomHeading,
  h3: CustomHeading,
}
</script>

<template>
  <MDCRenderer :body="mdcAst" :components="customComponents" />
</template>
```

## Dynamic Component Resolution

For large applications with many components, use the `componentsManifest` prop for lazy loading:

```vue
<script setup lang="ts">
import { MDCRenderer } from 'mdc-syntax/vue'

// Component manifest for dynamic imports
function componentsManifest(name: string) {
  const components: Record<string, () => Promise<any>> = {
    alert: () => import('./components/Alert.vue'),
    card: () => import('./components/Card.vue'),
    tabs: () => import('./components/Tabs.vue'),
    code: () => import('./components/Code.vue'),
  }

  const loader = components[name]
  if (!loader) {
    throw new Error(`Component "${name}" not found`)
  }

  return loader()
}
</script>

<template>
  <MDCRenderer
    :body="mdcAst"
    :components-manifest="componentsManifest"
  />
</template>
```

### Auto-generating Component Manifests

For Nuxt or Vite projects, you can auto-generate the manifest:

```typescript
// utils/components-manifest.ts
export function createComponentsManifest() {
  // Vite glob import
  const modules = import.meta.glob('../components/*.vue')

  return (name: string) => {
    const loader = modules[`../components/${name}.vue`]
    if (!loader) {
      console.warn(`Component "${name}" not found, using default rendering`)
      return Promise.resolve(null)
    }
    return loader()
  }
}
```

```vue
<script setup>
import { createComponentsManifest } from './utils/components-manifest'

const manifest = createComponentsManifest()
</script>

<template>
  <MDCRenderer
    :body="mdcAst"
    :components-manifest="manifest"
  />
</template>
```

## Streaming Support

`MDCRenderer` works seamlessly with streaming:

```vue
<script setup lang="ts">
import { MDCRenderer, useMDCStream } from 'mdc-syntax/vue'
import CustomAlert from './components/Alert.vue'

const { state: streamState, startStream } = useMDCStream()

const customComponents = {
  alert: CustomAlert,
}

async function loadContent() {
  const response = await fetch('/api/content')
  await startStream(response.body!)
}

// Start streaming
loadContent()
</script>

<template>
  <div>
    <MDCRenderer
      v-if="streamState.body"
      :body="streamState.body"
      :components="customComponents"
    />
    <div v-if="!streamState.isComplete" class="loading">
      Streaming content...
    </div>
  </div>
</template>
```

## Error Handling

`MDCRenderer` includes an error boundary that catches component errors during rendering:

```vue
<script setup lang="ts">
function handleError(error: Error) {
  console.error('Render error:', error)
  // Show error UI or fallback
}
</script>

<template>
  <MDCRenderer
    :body="mdcAst"
    :components="components"
    @error="handleError"
  />
</template>
```

During streaming, if a component throws an error (e.g., due to incomplete props), the error is caught and logged without crashing the app.

## Styling

The renderer wraps content in a `mdc-content` class:

```vue
<style>
.mdc-content {
  /* Base content styles */
  font-family: system-ui, sans-serif;
  line-height: 1.6;
}

.mdc-content h1 {
  font-size: 2.5rem;
  margin-top: 2rem;
}

.mdc-content h2 {
  font-size: 2rem;
  margin-top: 1.5rem;
}

.mdc-content p {
  margin-bottom: 1rem;
}

.mdc-content code {
  background: #f5f5f5;
  padding: 0.2rem 0.4rem;
  border-radius: 0.25rem;
  font-family: monospace;
}

.mdc-content pre {
  background: #1e1e1e;
  color: #d4d4d4;
  padding: 1rem;
  border-radius: 0.5rem;
  overflow-x: auto;
}
</style>
```

## Advanced Examples

### With Syntax Highlighting

```vue
<!-- components/CodeBlock.vue -->
<script setup lang="ts">
import { computed } from 'vue'
import { highlight } from './highlighter' // Your syntax highlighter

const props = defineProps<{
  language?: string
  __node?: any
}>()

const code = computed(() => {
  // Extract text content from children
  const textNode = props.__node?.children?.find((c: any) => c.type === 'text')
  return textNode?.value || ''
})

const highlighted = computed(() => {
  return highlight(code.value, props.language || 'text')
})
</script>

<template>
  <pre class="code-block"><code :class="`language-${language}`" v-html="highlighted" /></pre>
</template>
```

### With Image Optimization

```vue
<!-- components/OptimizedImage.vue -->
<script setup lang="ts">
import { computed } from 'vue'

const props = defineProps<{
  src?: string
  alt?: string
  width?: number | string
  height?: number | string
}>()

const optimizedSrc = computed(() => {
  // Add image optimization parameters
  if (!props.src)
    return ''
  const url = new URL(props.src, window.location.origin)
  url.searchParams.set('w', String(props.width || 800))
  url.searchParams.set('q', '80')
  return url.toString()
})
</script>

<template>
  <img
    :src="optimizedSrc"
    :alt="alt"
    :width="width"
    :height="height"
    loading="lazy"
  >
</template>
```

```vue
<script setup>
const components = {
  img: OptimizedImage,
}
</script>

<template>
  <MDCRenderer :body="mdcAst" :components="components" />
</template>
```

### With Link Security

```vue
<!-- components/SecureLink.vue -->
<script setup lang="ts">
import { computed } from 'vue'

const props = defineProps<{
  href?: string
}>()

const isExternal = computed(() => {
  if (!props.href)
    return false
  return props.href.startsWith('http://') || props.href.startsWith('https://')
})
</script>

<template>
  <a
    :href="href"
    :target="isExternal ? '_blank' : undefined"
    :rel="isExternal ? 'noopener noreferrer' : undefined"
    class="link"
  >
    <slot />
    <span v-if="isExternal" class="external-icon">↗</span>
  </a>
</template>

<style scoped>
.link {
  color: #0066cc;
  text-decoration: none;
}

.link:hover {
  text-decoration: underline;
}

.external-icon {
  font-size: 0.8em;
  margin-left: 0.25rem;
}
</style>
```

## TypeScript Support

Full TypeScript support with proper types:

```vue
<script setup lang="ts">
import type { MinimarkTree } from 'mdc-syntax/vue'
import type { Component } from 'vue'
import { MDCRenderer } from 'mdc-syntax/vue'

interface Props {
  content: MinimarkTree
  components: Record<string, Component>
}

const props = defineProps<Props>()
</script>

<template>
  <MDCRenderer
    :body="props.content"
    :components="props.components"
  />
</template>
```

## Performance Tips

1. **Use `shallowRef` for large ASTs**: When storing the AST in state, use `shallowRef` instead of `ref` to avoid deep reactivity:

```typescript
import { shallowRef } from 'vue'

const mdcAst = shallowRef<MinimarkTree>(result.body)
```

2. **Lazy load components**: Use `componentsManifest` for code splitting:

```typescript
const manifest = (name: string) => import(`./components/${name}.vue`)
```

3. **Memoize component mappings**: Don't recreate the components object on every render:

```typescript
const components = {
  alert: Alert,
  card: Card,
} // Outside component or in setup with const
```

4. **Use `v-once` for static content**: If the content doesn't change, use `v-once`:

```vue
<template>
  <MDCRenderer v-once :body="mdcAst" :components="components" />
</template>
```

## See Also

- [useMDCStream Composable](./use-mdc-stream) - Streaming integration
- [Parse API](./parse-api) - Generating MDC AST
- [Custom Components Guide](./custom-components) - Building custom components
