# useMDCStream Composable

The `useMDCStream` composable provides a reactive way to handle streaming MDC content in Vue applications.

## Overview

`useMDCStream` manages the state of streaming MDC content, automatically parsing chunks as they arrive and updating reactive state. It's perfect for real-time content rendering, AI-generated markdown, or progressive content loading.

## Installation

```typescript
import { useMDCStream } from 'mdc-syntax/vue'
```

## Basic Usage

```vue
<script setup lang="ts">
import { MDCRenderer, useMDCStream } from 'mdc-syntax/vue'

const { state, startStream, reset } = useMDCStream()

async function loadContent() {
  const response = await fetch('/api/content')
  await startStream(response.body!)
}

// Start loading
loadContent()
</script>

<template>
  <div>
    <MDCRenderer v-if="state.body" :body="state.body" />
    <div v-if="!state.isComplete" class="loading">
      Loading...
    </div>
  </div>
</template>
```

## API

### `useMDCStream(options?: MDCStreamOptions)`

Creates a new MDC stream handler with optional configuration.

**Parameters:**
- `options` - Optional configuration object

**Returns:**
```typescript
{
  state: Readonly<Ref<MDCStreamState>>
  isStreaming: Readonly<Ref<boolean>>
  startStream: (stream: Readable | ReadableStream<Uint8Array>) => Promise<void>
  reset: () => void
}
```

### Options

```typescript
interface MDCStreamOptions {
  onChunk?: (chunk: string) => void
  onComplete?: (result: { body: MinimarkTree, data: any, toc?: any }) => void
  onError?: (error: Error) => void
}
```

#### `onChunk`

Callback function called for each chunk received (excluding the final chunk).

**Example:**

```vue
<script setup lang="ts">
import { useMDCStream } from 'mdc-syntax/vue'
import { ref } from 'vue'

const bytesReceived = ref(0)
const chunkCount = ref(0)

const { state, startStream } = useMDCStream({
  onChunk(chunk) {
    bytesReceived.value += chunk.length
    chunkCount.value++
  }
})
</script>

<template>
  <div>
    <div>Chunks: {{ chunkCount }}</div>
    <div>Bytes: {{ bytesReceived }}</div>
    <MDCRenderer :body="state.body" />
  </div>
</template>
```

#### `onComplete`

Callback function called when the stream completes successfully.

**Example:**

```vue
<script setup lang="ts">
import { useMDCStream } from 'mdc-syntax/vue'

const { state, startStream } = useMDCStream({
  onComplete(result) {
    console.log('Stream complete!')
    console.log('Table of contents:', result.toc)
    console.log('Frontmatter:', result.data)

    // Navigate to first heading
    if (result.toc?.links?.length > 0) {
      window.location.hash = result.toc.links[0].id
    }
  }
})
</script>
```

#### `onError`

Callback function called if an error occurs during streaming.

**Example:**

```vue
<script setup lang="ts">
import { useMDCStream } from 'mdc-syntax/vue'
import { ref } from 'vue'

const errorMessage = ref<string>()

const { state, startStream } = useMDCStream({
  onError(error) {
    console.error('Stream error:', error)
    errorMessage.value = error.message
  }
})
</script>

<template>
  <div>
    <div v-if="errorMessage" class="error">
      Error: {{ errorMessage }}
    </div>
    <MDCRenderer v-else :body="state.body" />
  </div>
</template>
```

### State

The reactive state object contains the current streaming state:

```typescript
interface MDCStreamState {
  body: MinimarkTree
  data: any
  isComplete: boolean
  excerpt?: MinimarkTree
  toc?: any
  error?: Error
}
```

**Properties:**

- `body` - Current parsed MDC AST (updates with each chunk)
- `data` - Frontmatter data (available once parsed)
- `isComplete` - Whether streaming is complete
- `excerpt` - Optional excerpt content
- `toc` - Table of contents (only available when complete)
- `error` - Error object if streaming failed

**Example:**

```vue
<script setup lang="ts">
import { MDCRenderer, useMDCStream } from 'mdc-syntax/vue'

const { state, startStream } = useMDCStream()
</script>

<template>
  <div>
    <div v-if="state.error" class="error">
      Error: {{ state.error.message }}
    </div>

    <div v-else-if="!state.isComplete" class="loading">
      <div class="spinner" />
      <div>Loading {{ state.body.value.length }} elements...</div>
    </div>

    <div v-else class="content">
      <aside v-if="state.toc">
        <TableOfContents :toc="state.toc" />
      </aside>
      <MDCRenderer :body="state.body" />
    </div>
  </div>
</template>
```

### `isStreaming`

Reactive boolean indicating whether a stream is currently active.

**Example:**

```vue
<script setup lang="ts">
import { MDCRenderer, useMDCStream } from 'mdc-syntax/vue'

const { state, isStreaming, startStream } = useMDCStream()

async function loadContent() {
  const response = await fetch('/api/content')
  await startStream(response.body!)
}
</script>

<template>
  <div>
    <button :disabled="isStreaming" @click="loadContent">
      {{ isStreaming ? 'Loading...' : 'Load Content' }}
    </button>

    <MDCRenderer v-if="state.body" :body="state.body" />
  </div>
</template>
```

### `startStream(stream, useMarkdownIt?)`

Starts streaming and parsing content.

**Parameters:**
- `stream` - Node.js Readable or Web ReadableStream
- `useMarkdownIt` - (Optional) Use markdown-it parser, defaults to `false`

**Returns:** Promise that resolves when streaming completes

**Example:**

```typescript
// Web stream (Fetch API)
// Node.js stream
import { createReadStream } from 'node:fs'

const response = await fetch('/content.md')
await startStream(response.body!)
const fileStream = createReadStream('content.md')
await startStream(fileStream)
```

### `reset()`

Resets the stream state to initial values.

**Example:**

```vue
<script setup lang="ts">
import { MDCRenderer, useMDCStream } from 'mdc-syntax/vue'

const { state, startStream, reset } = useMDCStream()

async function reload() {
  reset() // Clear existing content
  const response = await fetch('/api/content')
  await startStream(response.body!)
}
</script>

<template>
  <div>
    <button @click="reset">
      Clear Content
    </button>
    <button @click="reload">
      Reload
    </button>

    <MDCRenderer v-if="state.body.value.length > 0" :body="state.body" />
  </div>
</template>
```

## Examples

### AI Chat Streaming

```vue
<script setup lang="ts">
import { MDCRenderer, useMDCStream } from 'mdc-syntax/vue'
import { ref } from 'vue'

interface Message {
  id: string
  author: string
  body: any
}

const messages = ref<Message[]>([])
const input = ref('')

const { state, isStreaming, startStream, reset } = useMDCStream({
  onComplete(result) {
    // Add completed message to history
    messages.value.push({
      id: Date.now().toString(),
      author: 'AI',
      body: result.body
    })
    reset()
  }
})

async function sendMessage() {
  if (!input.value.trim() || isStreaming.value)
    return

  // Add user message
  messages.value.push({
    id: Date.now().toString(),
    author: 'You',
    body: { type: 'root', children: [
      { type: 'element', tag: 'p', props: {}, children: [
        { type: 'text', value: input.value }
      ] }
    ] }
  })

  const message = input.value
  input.value = ''

  // Stream AI response
  const response = await fetch('/api/chat', {
    method: 'POST',
    body: JSON.stringify({ message }),
    headers: { 'Content-Type': 'application/json' }
  })

  await startStream(response.body!)
}
</script>

<template>
  <div class="chat">
    <div class="messages">
      <div v-for="message in messages" :key="message.id" class="message">
        <div class="message-author">
          {{ message.author }}
        </div>
        <MDCRenderer :body="message.body" />
      </div>

      <!-- Current streaming message -->
      <div v-if="isStreaming" class="message streaming">
        <div class="message-author">
          AI
        </div>
        <MDCRenderer :body="state.body" />
        <div class="cursor" />
      </div>
    </div>

    <div class="input">
      <input
        v-model="input"
        :disabled="isStreaming"
        placeholder="Type a message..."
        @keyup.enter="sendMessage"
      >
      <button :disabled="isStreaming" @click="sendMessage">
        Send
      </button>
    </div>
  </div>
</template>

<style scoped>
.chat {
  display: flex;
  flex-direction: column;
  height: 100vh;
}

.messages {
  flex: 1;
  overflow-y: auto;
  padding: 1rem;
}

.message {
  margin-bottom: 1rem;
  padding: 1rem;
  background: #f5f5f5;
  border-radius: 0.5rem;
}

.message.streaming {
  background: #e3f2fd;
}

.cursor {
  display: inline-block;
  width: 0.5rem;
  height: 1rem;
  background: #333;
  animation: blink 1s infinite;
}

@keyframes blink {
  50% { opacity: 0; }
}

.input {
  display: flex;
  gap: 0.5rem;
  padding: 1rem;
  border-top: 1px solid #ddd;
}

.input input {
  flex: 1;
  padding: 0.5rem;
  border: 1px solid #ddd;
  border-radius: 0.25rem;
}

.input button {
  padding: 0.5rem 1rem;
  background: #0066cc;
  color: white;
  border: none;
  border-radius: 0.25rem;
  cursor: pointer;
}

.input button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
</style>
```

### Progress Indicator

```vue
<script setup lang="ts">
import { MDCRenderer, useMDCStream } from 'mdc-syntax/vue'
import { computed, ref } from 'vue'

const bytesReceived = ref(0)
const chunkCount = ref(0)
const totalBytes = ref(0)

const { state, startStream } = useMDCStream({
  onChunk(chunk) {
    bytesReceived.value += chunk.length
    chunkCount.value++
  }
})

const progress = computed(() => {
  if (totalBytes.value === 0)
    return 0
  return Math.min((bytesReceived.value / totalBytes.value) * 100, 100)
})

const elementsCount = computed(() => state.value.body.value.length)

async function loadWithProgress() {
  const response = await fetch('/api/content')

  // Get total size from Content-Length header
  const contentLength = response.headers.get('Content-Length')
  if (contentLength) {
    totalBytes.value = Number.parseInt(contentLength)
  }

  await startStream(response.body!)
}

loadWithProgress()
</script>

<template>
  <div>
    <div class="progress-bar">
      <div
        class="progress-fill"
        :style="{ width: `${progress}%` }"
      />
    </div>

    <div class="stats">
      <span>{{ chunkCount }} chunks</span>
      <span>{{ bytesReceived }} bytes</span>
      <span>{{ elementsCount }} elements</span>
    </div>

    <MDCRenderer :body="state.body" />
  </div>
</template>

<style scoped>
.progress-bar {
  height: 4px;
  background: #f0f0f0;
  border-radius: 2px;
  overflow: hidden;
  margin-bottom: 1rem;
}

.progress-fill {
  height: 100%;
  background: #0066cc;
  transition: width 0.3s ease;
}

.stats {
  display: flex;
  gap: 1rem;
  margin-bottom: 1rem;
  font-size: 0.875rem;
  color: #666;
}
</style>
```

### Multiple Concurrent Streams

```vue
<script setup lang="ts">
import { MDCRenderer, useMDCStream } from 'mdc-syntax/vue'
import { reactive, ref } from 'vue'

interface StreamHandler {
  id: string
  title: string
  state: any
  startStream: any
}

const streams = ref<StreamHandler[]>([])

async function addStream(url: string, title: string) {
  const { state, startStream } = useMDCStream()

  const handler = {
    id: Date.now().toString(),
    title,
    state,
    startStream
  }

  streams.value.push(handler)

  const response = await fetch(url)
  await startStream(response.body!)
}

// Load multiple streams concurrently
Promise.all([
  addStream('/api/article1', 'Article 1'),
  addStream('/api/article2', 'Article 2'),
  addStream('/api/article3', 'Article 3'),
])
</script>

<template>
  <div class="streams">
    <div v-for="stream in streams" :key="stream.id" class="stream">
      <h3>{{ stream.title }}</h3>

      <div v-if="stream.state.value.isComplete" class="complete">
        âœ“ Complete
      </div>

      <MDCRenderer :body="stream.state.value.body" />
    </div>
  </div>
</template>

<style scoped>
.streams {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 2rem;
}

.stream {
  border: 1px solid #ddd;
  border-radius: 0.5rem;
  padding: 1rem;
}

.complete {
  color: #4caf50;
  font-weight: 600;
  margin-bottom: 0.5rem;
}
</style>
```

### With Custom Components

```vue
<script setup lang="ts">
import { MDCRenderer, useMDCStream } from 'mdc-syntax/vue'
import CustomAlert from './components/Alert.vue'
import CustomCard from './components/Card.vue'
import CustomCode from './components/Code.vue'

const customComponents = {
  alert: CustomAlert,
  card: CustomCard,
  pre: CustomCode,
}

const { state, startStream } = useMDCStream()

async function loadContent() {
  const response = await fetch('/api/content')
  await startStream(response.body!)
}

loadContent()
</script>

<template>
  <div>
    <MDCRenderer
      v-if="state.body"
      :body="state.body"
      :components="customComponents"
    />

    <div v-if="!state.isComplete" class="loading">
      Streaming...
    </div>
  </div>
</template>
```

## TypeScript Support

Full TypeScript support with proper types:

```typescript
import type { MinimarkTree, MDCStreamOptions } from 'mdc-syntax/vue'
import { useMDCStream } from 'mdc-syntax/vue'

const options: MDCStreamOptions = {
  onChunk(chunk: string) {
    console.log('Chunk:', chunk.length)
  },
  onComplete(result: { body: MinimarkTree, data: any, toc?: any }) {
    console.log('Complete:', result.toc)
  },
  onError(error: Error) {
    console.error('Error:', error.message)
  }
}

const { state, isStreaming, startStream, reset } = useMDCStream(options)
```

## Performance Tips

1. **Use `shallowRef`**: The composable already uses `shallowRef` internally for optimal performance

2. **Debounce renders**: For very fast streams, consider debouncing updates:

```vue
<script setup>
import { ref, watchDebounced } from '@vueuse/core'
import { useMDCStream } from 'mdc-syntax/vue'

const { state } = useMDCStream()
const debouncedBody = ref(state.value.body)

watchDebounced(
  () => state.value.body,
  (newBody) => { debouncedBody.value = newBody },
  { debounce: 100 }
)
</script>

<template>
  <MDCRenderer :body="debouncedBody" />
</template>
```

3. **Lazy load components**: Use dynamic components for better code splitting

4. **Clean up**: Call `reset()` when unmounting or navigating away

## See Also

- [MDCRenderer Component](./mdc-renderer) - Rendering MDC content
- [Parse API](./parse-api) - Parsing MDC content
