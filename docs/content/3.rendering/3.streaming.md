---
title: Streaming
description: Render Comark content in real-time as it arrives, with auto-close for incomplete syntax and caret indicators for AI chat interfaces.
navigation:
  title: Streaming
  icon: i-lucide-radio
links:
  - label: Auto-Close API
    icon: i-lucide-parentheses
    to: /api/auto-close
    color: neutral
    variant: subtle
  - label: Parse API
    icon: i-lucide-code
    to: /api/parse
    color: neutral
    variant: subtle
---

Comark supports real-time incremental parsing, making it ideal for AI chat interfaces, live previews, and any scenario where content arrives in chunks.

## Why Streaming?

When an LLM generates a response, text arrives token by token. Without streaming support, you'd need to wait for the full response before rendering. Comark solves this with two features:

1. **`autoClose`** - Automatically closes incomplete Markdown syntax (`**bold` becomes `**bold**`)
2. **`streaming` prop** - Tells the renderer the content is still arriving, preventing layout shifts

## Vue Streaming

Enable streaming by setting the `streaming` prop to `true` while content is being received:

```vue [components/AiChat.vue]
<script setup>
import { ref } from 'vue'
import { Comark } from 'comark/vue'

const content = ref('')
const isStreaming = ref(false)

async function askAI(prompt: string) {
  content.value = ''
  isStreaming.value = true

  const response = await fetch('/api/chat', {
    method: 'POST',
    body: JSON.stringify({ prompt }),
  })

  const reader = response.body!.getReader()
  const decoder = new TextDecoder()

  while (true) {
    const { done, value } = await reader.read()
    if (done) break
    content.value += decoder.decode(value, { stream: true })
  }

  isStreaming.value = false
}
</script>

<template>
  <Comark
    :streaming="isStreaming"
    :options="{ autoClose: true }"
    caret
  >
    {{ content }}
  </Comark>
</template>
```

::callout{icon="i-lucide-info" color="info"}
The `autoClose` option automatically closes incomplete syntax at the end of each chunk, so `**bold text` renders as **bold text** instead of plain text with asterisks.
::

## React Streaming

```tsx [components/AiChat.tsx]
import { useState } from 'react'
import { Comark } from 'comark/react'

export default function AiChat() {
  const [content, setContent] = useState('')
  const [isStreaming, setIsStreaming] = useState(false)

  async function askAI(prompt: string) {
    setContent('')
    setIsStreaming(true)

    const response = await fetch('/api/chat', {
      method: 'POST',
      body: JSON.stringify({ prompt }),
    })

    const reader = response.body!.getReader()
    const decoder = new TextDecoder()
    let accumulated = ''

    while (true) {
      const { done, value } = await reader.read()
      if (done) break
      accumulated += decoder.decode(value, { stream: true })
      setContent(accumulated)
    }

    setIsStreaming(false)
  }

  return (
    <Comark
      streaming={isStreaming}
      options={{ autoClose: true }}
      caret
    >
      {content}
    </Comark>
  )
}
```

## Caret Indicator

The `caret` prop appends a blinking cursor to the last text node, giving visual feedback that content is still arriving:

```vue
<Comark :streaming="isStreaming" caret>
  {{ content }}
</Comark>
```

Customize the caret's CSS class:

```vue
<Comark :streaming="isStreaming" :caret="{ class: 'my-caret' }">
  {{ content }}
</Comark>
```

```css
.my-caret {
  display: inline-block;
  width: 2px;
  height: 1em;
  background: currentColor;
  animation: blink 1s step-end infinite;
  vertical-align: text-bottom;
}

@keyframes blink {
  50% { opacity: 0; }
}
```

::callout{icon="i-lucide-info" color="info"}
The caret is only visible while `streaming` is `true`. Once streaming completes, the caret disappears automatically.
::

## How Auto-Close Works

The `autoCloseMarkdown` function detects and closes unclosed syntax:

::code-group

```typescript [Code]
import { autoCloseMarkdown } from 'comark'

autoCloseMarkdown('**bold text')
autoCloseMarkdown('- Item 1\n- Item 2\n  - Nested')
autoCloseMarkdown('::alert{type="info"}\nContent')
```

```text [Output]
**bold text**
- Item 1\n- Item 2\n  - Nested
::alert{type="info"}\nContent\n::
```

::

Supported auto-close patterns:

| Syntax | Example | Auto-closed |
|--------|---------|-------------|
| Bold | `**bold` | `**bold**` |
| Italic | `*italic` | `*italic*` |
| Strikethrough | `~~strike` | `~~strike~~` |
| Inline code | `` `code `` | `` `code` `` |
| Code block | ` ```js\ncode ` | ` ```js\ncode\n``` ` |
| Block component | `::alert\nText` | `::alert\nText\n::` |

## Advanced: Manual Stream Parsing

For full control over the parsing pipeline, parse each chunk manually:

```typescript
import { parse, autoCloseMarkdown } from 'comark'

let accumulated = ''

async function onChunk(chunk: string) {
  accumulated += chunk

  const closed = autoCloseMarkdown(accumulated)
  const tree = await parse(closed, { autoClose: false })

  render(tree)
}

async function onComplete() {
  const tree = await parse(accumulated)
  render(tree)
}
```

::callout{icon="i-lucide-triangle-alert" color="warning"}
Always use `autoCloseMarkdown` on intermediate chunks, but parse the final content **without** auto-close to get the accurate final AST.
::

---

## Next Steps

- [Auto-Close API](/api/auto-close) - Detailed auto-close function reference
- [Vue Rendering](/rendering/vue) - Full Vue component API
- [React Rendering](/rendering/react) - Full React component API
- [Parse API](/api/parse) - Parser options and configuration
